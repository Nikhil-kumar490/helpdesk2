<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta meta name="viewport" content="width=device-width, user-scalable=no" />
    <title>Helpdesk</title>
</head>
   
<script
	src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.2/dist/umd/popper.min.js"
	integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB"
	crossorigin="anonymous"
></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link
	rel="stylesheet"
	href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css"
/>
<link rel="icon" href="assets/images/logo.png" type="image/png">
<link rel="stylesheet" type="text/css" href="../assets/css/style.css" />
<script src="../assets/js/script.js"></script>
<style>
 
  </style>
<body  onload="waterm()">
  <header class="navbar navbar-expand-md d-flex flex-wrap justify-content-center mt-2 p-2 mb-2 border-bottom">
   <div id="top_bar">
    <a href="#" class="d-flex align-items-center mb-3 mb-md-0 me-md-auto link-body-emphasis text-decoration-none">
      <img src="../assets/images/logo.png" id="imglogo">
      <span class="fs-4 mr-5 lo"><h2 class="bold-text">Helpdesk</h2></span>
    </a>
   </div>
    <div class="container-fluid" id="sec_nav">
      <button class="navbar-toggler" type="button" onclick="openLeftSidebar()">
      <span class="navbar-toggler-icon"></span>
      </button>
     <div id="leftSidebar" class="sidebar-left">
      <a href="javascript:void(0)" class="closebtn" onclick="closeLeftSidebar()">&times;</a>
      <h2>semester 5</h2>
      <a href="../semester5/index.html">Software tech.</a>
      <a href="../semester5/formal.html" class="active">Formal lang.</a>
      <a href="../semester5/ai.html">AI</a>
      <a href="../semester5/ml.html">ML</a>
      <a href="../semester5/const.html">Indian Const.</a>
      <a href="../semester5/comp_netw.html">Comp. Networks</a>
      <a href="../semester5/big.html">Big Data</a>
      <a href="../semester5/cloud.html">Cloud Computing</a>

      <h2>semester 6</h2>
      <a href="#">Comming Soon....</a>
     
  </div>
  <div class="semester">semester-5</div>

      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" id="upper_menu_btn" data-bs-target="#collapsibleNavbar">
 <i class="fa fa-arrow-down" aria-hidden="true"></i>      </button>
      <div class="collapse navbar-collapse" id="collapsibleNavbar" >
        <ul class="nav nav-pills navbar-nav ms-auto" id="myNav">
          <!-- 1st Year -->
          <li class="nav-item">
            <a class="nav-link" href="../semester1/index.html">1st Year</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="../semester3/index.html">2nd Year</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="../semester5/index.html">3rd Year</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="../semester7/index.html">4th Year</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="../NPTEL/index.html">NPTEL</a>
          </li>
        </ul>
      </div>
    </div>
  </header>
  
  
    <div id="body">
      <div class="heading_name">Formal Languages</div>
      <hr>
      <marquee>
        <a href="./formal_ass.html">Assignment</a>
      </marquee>
      <hr>
      
      <center><Strong><h3>Automata</h3></Strong></center>
      &rarr; Automata is an exciting and theoretical branch of computer science.

     <br>
     &rarr; Automation = an abstract computing device.
     <br>
     &rarr; Simply, Automata theory deals with the logic of computation with respect to simple machines, referred to as automata.
     <br>
     &rarr; Through automata, Computer scientists can understand how machines compute functions and solve problems.

     <br><br>
     <h4>Basic Concepts of automata theory: </h4>
      <strong><h4>1. Alphabets : </h4></strong>
      &rarr; It is a finite, non-empty sets of symbols. <br>
      &rarr; Representation : &Sigma; (Sigma) <br>
      &rarr; Ex => Binary symbols : &Sigma; = {0,1}
      <br>
<br>
      <strong><h4>2. Strings : </h4></strong>
      &rarr; A String or word is a finite collection of Symbols selected from the Alphabets (&Sigma;). <br>

      &rarr; A String can be empty, which is represented by &epsilon; ("epsilon").
      <br><br>

      <strong>Length of String: </strong>The length of the String is denoted by |w| and it is the number positions for the symbol in the String. For Example:

      <br>
      w = 01101 has length = 5, i.e. |w| = 5.
      <br><br>

      <Strong>Empty String: </Strong> The empty String is the string with zero occurance of Symbols. The empty string is represented by &epsilon;. 
<br><br>
<strong><h4>3. Languages </h4></strong>
&rarr; L- is said to be the language over a given set of Alphabets, if L belongs to &Sigma;<sup>*</sup>
<br>
For Ex - L is a language that comprises of set of even numbers over the alphabets &Sigma; = {0,1}. 

<br><br>
<h3>Finite Automata</h3>
&rarr; Finite automata are mainly used for pattern recognition. <br>
&rarr; It takes the string of Symbols as input and changes its states accordingly. When the desired symbol is found, then the transition occurs. <br>
&rarr; At the time of transition, the automata can either move to the next state or stay in the same state.
<br>
&rarr; Finite automata have two states, <b>Accept state</b> and <b>Reject State</b>. 

<br><br>
<ul>
  <li>Q = Finite set of States</li>
  <li>&Sigma; = Finite sets of the input Symbol</li>
  <li>q <sub>o</sub> = initial State</li>
  <li>F = Final State</li>
  <li>&delta; = transition functions</li>
</ul>

<h4>Types of finite Automata: </h4>
<ol type="1">
  <li>DFA (Deterministic Finite Automata)</li>
  <li>NFA (Non-Deterministic Finite Automata)</li>
</ol>
<h4>DFA</h4>
&rarr; DFA refers to Deterministic finite automata. Deterministic refers to the uniqueness of the computation.
<br>
&rarr; In DFA, there is only one path for specific input from the current State to the next state. <br>
&rarr; DFA does not accept the null move, i.e, the DFA cannot change state without any input character.
<br>
<br>
<h4>Transition Diagram</h4>
A transition diagram is a graphical way to represent a finite automaton. It shows the following: <br>

<Strong>1. States: </Strong>Represented by circles. One state is the start state (marked with an arrow pointing to it) and some states can be final states (double circles). <br>
<Strong>2. Transitions:</Strong> Arrows between states, labeled with input symbols, showing how the automaton moves from one state to another based on the input. <br>
<Strong>3. Input Symbols: </Strong>These are the symbols that cause transitions between states. <br><br>
The automaton starts in the start state and follows the transitions according to the input symbols. If it reaches a final state after reading the input, the input is accepted. If not, the input is rejected.
<br>
<br>
<h4>Transition Table</h4>
<p>A <strong>transition table</strong> is a tabular representation of the transitions of a finite automaton. It details how the automaton changes states in response to input symbols from its alphabet. This table is crucial in understanding the behavior of deterministic finite automata (DFA) or non-deterministic finite automata (NFA).</p>



<p><strong>Example Transition Table:</strong></p>

<table>
    <thead>
        <tr>
            <th>State</th>
            <th>Input `a`</th>
            <th>Input `b`</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>q0</td>
            <td>q1</td>
            <td>-</td>
        </tr>
        <tr>
            <td>q1</td>
            <td>-</td>
            <td>q2</td>
        </tr>
        <tr>
            <td>q2</td>
            <td>q2</td>
            <td>q2</td>
        </tr>
    </tbody>
</table>
<br>
<h4>Nondeterministic Finite Automaton (NFA)</h4>

    <p>A <strong>Nondeterministic Finite Automaton (NFA)</strong> is a theoretical model of computation used in automata theory. An NFA is similar to a Deterministic Finite Automaton (DFA), but it allows multiple possible transitions for the same input symbol from a given state, including the possibility of moving to multiple states or no states at all.</p>

    <h4>Key Symbols in Nondeterministic Finite Automaton (NFA)</h4>

    <table>
        <thead>
            <tr>
                <th>Symbol</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Q</td>
                <td>Set of all states in the automaton</td>
            </tr>
            <tr>
                <td>&Sigma;</td>
                <td>Input alphabet (set of allowed input symbols)</td>
            </tr>
            <tr>
                <td>&delta;</td>
                <td>Transition function that maps a state and input symbol to a set of next possible states</td>
            </tr>
            <tr>
                <td>q&#8320;</td>
                <td>Start state (initial state of the automaton)</td>
            </tr>
            <tr>
                <td>F</td>
                <td>Set of final (accepting) states</td>
            </tr>
            <tr>
                <td>&rarr;</td>
                <td>Represents the start state in the diagram (arrow pointing to the start state)</td>
            </tr>
            <tr>
                <td>&#8943;</td>
                <td>Ellipsis, used when multiple transitions are possible</td>
            </tr>
            <tr>
                <td>&Lambda; or &epsilon;</td>
                <td>Represents an empty string transition (no input required to move to the next state)</td>
            </tr>
        </tbody>
    </table>

    <h3>Explanation</h3>
    <p><strong>Q:</strong> This is the set of all possible states in the NFA.</p>
    <p><strong>&Sigma; (Sigma):</strong> Represents the input symbols the automaton can process.</p>
    <p><strong>&delta; (Delta):</strong> The transition function that tells the NFA where to move based on the current state and input.</p>
    <p><strong>q&#8320;:</strong> The start state where the automaton begins processing the input.</p>
    <p><strong>F:</strong> The set of final states where the automaton halts and accepts the input.</p>
    <p><strong>&rarr;:</strong> Indicates the initial state in a transition diagram.</p>
    <p><strong>&Lambda; or &epsilon;:</strong> Represents an epsilon transition, where the automaton can change states without consuming any input.</p>


    <h2>Comparison Between NFA and DFA</h2>

    <table style="font-size: 12px;">
        <thead>
            <tr>
                <th>Criteria</th>
                <th>NFA (Nondeterministic Finite Automaton)</th>
                <th>DFA (Deterministic Finite Automaton)</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Definition</td>
                <td>An automaton where for a given input symbol, the machine can transition to multiple states or no state at all.</td>
                <td>An automaton where for a given input symbol, the machine can transition to exactly one state.</td>
            </tr>
            <tr>
                <td>Transition Function</td>
                <td>&delta;(q, a) → set of states (can be zero, one, or more states)</td>
                <td>&delta;(q, a) → single state (always one specific state)</td>
            </tr>
            <tr>
                <td>Epsilon (ε) Transitions</td>
                <td>Allowed (the automaton can change states without consuming input).</td>
                <td>Not allowed (each transition requires an input symbol).</td>
            </tr>
            <tr>
                <td>Determinism</td>
                <td>Non-deterministic (the automaton can choose multiple paths).</td>
                <td>Deterministic (only one path for each input symbol from any given state).</td>
            </tr>
            <tr>
                <td>Number of Possible Transitions</td>
                <td>Can have multiple transitions for the same input symbol.</td>
                <td>Only one transition per input symbol per state.</td>
            </tr>
            <tr>
                <td>Acceptance of Input</td>
                <td>An input is accepted if at least one possible transition sequence leads to a final state.</td>
                <td>An input is accepted only if the unique transition sequence leads to a final state.</td>
            </tr>
            <tr>
                <td>Memory Usage</td>
                <td>Generally requires less memory as multiple paths are conceptually handled.</td>
                <td>Requires more memory as the automaton must store information for every specific state and transition.</td>
            </tr>
            <tr>
                <td>Conversion</td>
                <td>Can be converted to an equivalent DFA.</td>
                <td>Cannot be converted to NFA (but any NFA can be converted to DFA).</td>
            </tr>
            <tr>
                <td>Construction</td>
                <td>Easier to construct for some languages due to non-determinism.</td>
                <td>Can be more difficult to construct as it requires explicitly defined transitions for every state and symbol.</td>
            </tr>
            <tr>
                <td>Performance</td>
                <td>Can be faster in recognizing languages due to multiple parallel paths.</td>
                <td>Generally slower due to the need to process a single path deterministically.</td>
            </tr>
        </tbody>
    </table>


























      <div id="watermark">@Debuggers</div>

      <div id="up">
        <a href="#" id="goToTopButton" class="go-to-top-button">
          <span><i class="fa fa-arrow-up" aria-hidden="true" id="arrow"></i></span>
      </a>
      </div>  
     <hr>
     <center>
Some Important Questions
     </center>
<hr>

<h4>Q1: What is Finite Automata?</h4>
<p>A finite automaton is a mathematical model of computation used to design both computer programs and sequential logic circuits. It consists of states, transitions, an initial state, and a set of accepting states. Finite automata are used to recognize regular languages.</p>


<h4>Q2: What is a Moore machine?</h4>
<p>A Moore machine is a finite state machine where the output depends only on the current state. The outputs are produced in response to entering a state, not by the transitions. It is defined by a 6-tuple (Q, Σ, Δ, δ, λ, q₀), where λ maps states to outputs.</p>

<h4>Q3: What is a Mealy machine?</h4>
<p>A Mealy machine is a finite state machine where the output depends on both the current state and the input. It is described by a 6-tuple (Q, Σ, Δ, δ, λ, q₀), where λ maps input and state pairs to outputs. Mealy machines can react faster compared to Moore machines.</p>


<h4>Q4: What is a DFA?</h4>
<p>A DFA, or Deterministic Finite Automaton, is a type of finite automaton where each state has exactly one transition for each symbol in the input alphabet. It is deterministic, meaning that the machine’s behavior is entirely predictable, and there is no ambiguity in transitions.</p>


<h4>Q5: What is the difference between NFA and DFA?</h4>
<p>In an NFA (Non-deterministic Finite Automaton), for a given state and input symbol, there can be multiple possible next states. In contrast, a DFA has exactly one transition for each symbol in the input alphabet from any state. Despite this difference, both DFA and NFA recognize the same set of languages, the regular languages.</p>


<h4>Q6: What is an ε-NFA?</h4>
<p>An ε-NFA is a type of NFA where transitions can occur without consuming any input symbol (ε-transitions). These ε-transitions allow the automaton to change states spontaneously. ε-NFAs can be converted to equivalent NFAs or DFAs that recognize the same language.</p>


<h4>Q7: What is ε-closure?</h4>
<p>The ε-closure of a state in an ε-NFA is the set of all states that can be reached from the given state through ε-transitions. It includes the state itself and any other states that can be reached by following ε-transitions from that state.</p>

<section>
    <strong>
     8) Construct a DFA for the language over {0, 1}* such that it contains “000” as a substring.
    </strong> <br>
     <img id="img1" src="../assets/images/formal/q1.png">
     <br>
    <strong> 9) Define (a) Finite Automata (FA) (b) Transition Diagram</strong>

     <br>
     
         <h5 style="color: #2c3e50;">Finite Automata (FA)</h5>
         <p>
             A Finite Automaton (FA) is a theoretical model of computation used to design and analyze the behavior of digital circuits and algorithms. It consists of a finite number of states, transitions between these states, and an input alphabet. A finite automaton can be categorized into two main types:
         </p>
         <ul>
             <li>
                 <strong>Deterministic Finite Automaton (DFA):</strong> For each state and input symbol, there is exactly one transition to a next state. The DFA has a unique path for each input string.
             </li>
             <li>
                 <strong>Nondeterministic Finite Automaton (NFA):</strong> For a given state and input symbol, there can be multiple possible transitions, or none at all. An NFA may have multiple paths for the same input string.
             </li>
         </ul>
         <p>
             An FA can be represented formally by a 5-tuple <code>(Q, &Sigma;, &delta;, q<sub>0</sub>, F)</code>, where:
         </p>
         <ul>
             <li><strong>Q</strong> is a finite set of states.</li>
             <li><strong>&Sigma;</strong> is a finite set of input symbols (alphabet).</li>
             <li><strong>&delta;</strong> is the transition function <code>&delta;: Q &times; &Sigma; &rarr; Q</code> (for DFA) or <code>&delta;: Q &times; &Sigma; &rarr; 2<sup>Q</sup></code> (for NFA).</li>
             <li><strong>q<sub>0</sub></strong> is the start state.</li>
             <li><strong>F</strong> is the set of accept states.</li>
         </ul>
     
         <h5 style="color: #2c3e50;">Transition Diagram</h5>
         <p>
             A Transition Diagram is a graphical representation of a finite automaton. It visually shows the states and transitions of the automaton, making it easier to understand and analyze its behavior. In a transition diagram:
         </p>
         <ul>
             <li><strong>States</strong> are represented as circles or nodes.</li>
             <li><strong>Transitions</strong> are shown as arrows connecting the states, labeled with the input symbols that cause the transition.</li>
             <li>The <strong>start state</strong> is typically indicated with an arrow pointing to it from nowhere.</li>
             <li><strong>Accept states</strong> are often denoted with a double circle or a different color to signify that reaching these states indicates acceptance of the input string.</li>
         </ul>
         <p>
             The transition diagram provides a clear, visual way to understand how the automaton processes input and moves from state to state based on input symbols.
         </p>
         <img id="img1" src="../assets/images/formal/dfanfa.png">
         <br>
<strong>10) State the difference between NFA and DFA. 
</strong>
         <br>

<table style="width: 80vw;">
 <thead>
     <tr>
         <th>Aspect</th>
         <th>NFA (Nondeterministic Finite Automaton)</th>
         <th>DFA (Deterministic Finite Automaton)</th>
     </tr>
 </thead>
 <tbody>
     <tr>
         <td>Transition Function</td>
         <td>The transition function &delta; can lead to multiple possible next states or none at all. <br> &delta;: Q &times; &Sigma; &rarr; 2<sup>Q</sup>.</td>
         <td>The transition function &delta; leads to exactly one next state for each state and input symbol. <br> &delta;: Q &times; &Sigma; &rarr; Q.</td>
     </tr>
     <tr>
         <td>Paths</td>
         <td>Multiple possible paths for a given input string. The NFA can be in multiple states simultaneously.</td>
         <td>Single unique path for a given input string. The DFA is in exactly one state at any point in time.</td>
     </tr>
     <tr>
         <td>Epsilon Transitions</td>
         <td>Can have epsilon (&epsilon;) transitions, allowing state changes without consuming input.</td>
         <td>No epsilon (&epsilon;) transitions; state changes occur only with input symbols.</td>
     </tr>
     <tr>
         <td>Complexity and Computation</td>
         <td>More complex to implement due to multiple possible states. Conceptually simpler for certain languages.</td>
         <td>Simpler to implement due to deterministic behavior. Requires less computational overhead.</td>
     </tr>
 </tbody>
</table>
<br>
<strong>
 11) Convert the given NFA to DFA.

</strong>
<img id="img1" src="../assets/images/formal/q4.png">
<br><br>

<img id="img1" src="../assets/images/formal/q4_ans.jpg">
<br>
<strong>12) Describe DFA and NFA with the help of its Tuples.
</strong>
<br>
<div style="margin-bottom: 20px;">
 <h5 style="color: #2c3e50;">DFA (Deterministic Finite Automaton)</h5>
 <p>A DFA is defined by a 5-tuple (Q, &Sigma;, &delta;, q<sub>0</sub>, F), where:</p>
 <ul style="list-style-type: disc; margin-left: 20px;">
     <li><strong>Q:</strong> A finite set of states. <br> Example: Q = {q<sub>0</sub>, q<sub>1</sub>, q<sub>2</sub>}</li>
     <li><strong>&Sigma;:</strong> A finite set of input symbols (alphabet). <br> Example: &Sigma; = {0, 1}</li>
     <li><strong>&delta;:</strong> The transition function, &delta;: Q &times; &Sigma; &rarr; Q. <br> Example: 
         <ul style="list-style-type: circle; margin-left: 20px;">
             <li>&delta;(q<sub>0</sub>, 0) = q<sub>1</sub></li>
             <li>&delta;(q<sub>0</sub>, 1) = q<sub>2</sub></li>
             <li>&delta;(q<sub>1</sub>, 0) = q<sub>0</sub></li>
             <li>&delta;(q<sub>1</sub>, 1) = q<sub>1</sub></li>
         </ul>
     </li>
     <li><strong>q<sub>0</sub>:</strong> The start state. <br> Example: q<sub>0</sub></li>
     <li><strong>F:</strong> The set of accept states (final states). <br> Example: F = {q<sub>1</sub>}</li>
 </ul>
</div>

<div style="margin-bottom: 20px;">
 <h5 style="color: #2c3e50;">NFA (Nondeterministic Finite Automaton)</h5>
 <p>An NFA is defined by a 5-tuple (Q, &Sigma;, &delta;, q<sub>0</sub>, F), where:</p>
 <ul style="list-style-type: disc; margin-left: 20px;">
     <li><strong>Q:</strong> A finite set of states. <br> Example: Q = {q<sub>0</sub>, q<sub>1</sub>, q<sub>2</sub>}</li>
     <li><strong>&Sigma;:</strong> A finite set of input symbols (alphabet). <br> Example: &Sigma; = {0, 1}</li>
     <li><strong>&delta;:</strong> The transition function, &delta;: Q &times; &Sigma; &rarr; 2<sup>Q</sup>. <br> Example:
         <ul style="list-style-type: circle; margin-left: 20px;">
             <li>&delta;(q<sub>0</sub>, 0) = {q<sub>0</sub>, q<sub>1</sub>}</li>
             <li>&delta;(q<sub>0</sub>, 1) = {q<sub>0</sub>}</li>
             <li>&delta;(q<sub>1</sub>, 1) = {q<sub>2</sub>}</li>
             <li>&delta;(q<sub>2</sub>, 0) = {q<sub>2</sub>}</li>
         </ul>
     </li>
     <li><strong>q<sub>0</sub>:</strong> The start state. <br> Example: q<sub>0</sub></li>
     <li><strong>F:</strong> The set of accept states (final states). <br> Example: F = {q<sub>2</sub>}</li>
 </ul>
</div>
<strong>
 13) Minimize the DFA
</strong>
<br>
<img src="../assets/images/formal/q5.png" alt="" id="img1">
<br>
<img src="../assets/images/formal/q5_ans1.jpg" alt="" id="img1">
<img src="../assets/images/formal/q5_ans2.jpg" alt="" id="img1">
<br><br>
14) Design a FA with ∑ = {0, 1} accepts those string which starts with 1 and ends with 0.
<img src="../assets/images/formal/q14.png" alt="" id="img1">
<br><br>
15) Design FA with ∑ = {0, 1} accepts even number of 0's and even number of 1's.

<img src="../assets/images/formal/q15.png" alt="" id="img1">

<br><br>
16)Draw deterministic finite automata (DFA) of the language containing the set of all strings over {a, b} in which 2nd symbol from RHS is 'a'.
<img src="../assets/images/formal/q16.png" alt="" id="img1">
 <br><br>
 <h3>Turing Machine in Automata</h3>

 <h2>Components of a Turing Machine</h2>
 <ul>
     <li><strong>Tape</strong>: A potentially infinite memory divided into discrete cells, each holding a symbol from a finite alphabet.</li>
     <li><strong>Head</strong>: Reads and writes symbols on the tape and moves left or right based on the current state and symbol.</li>
     <li><strong>Finite State Control</strong>: Contains a finite set of states and determines actions based on the current state and symbol.</li>
     <li><strong>Alphabet</strong>:
         <ul>
             <li>Input symbols</li>
             <li>A special blank symbol (e.g., <code>&square;</code>)</li>
         </ul>
     </li>
     <li><strong>Transition Function</strong> (<code>&delta;</code>): Defines the machine's behavior as a mapping:
         <code>&delta;(Q &times; &Gamma;) &rarr; (Q &times; &Gamma; &times; {L, R})</code>
     </li>
     <li><strong>States</strong>:
         <ul>
             <li><strong>Start State</strong> (<code>q<sub>0</sub></code>): Where computation begins.</li>
             <li><strong>Accept State</strong> (<code>q<sub>accept</sub></code>): Signifies successful computation.</li>
             <li><strong>Reject State</strong> (<code>q<sub>reject</sub></code>): Signifies failure or rejection.</li>
         </ul>
     </li>
 </ul>

 <h2>Operation of a Turing Machine</h2>
 <p>The Turing Machine begins in the start state <code>q<sub>0</sub></code>, with the head positioned at the first cell of the tape. The current symbol and state determine:</p>
 <ul>
     <li>The symbol to write.</li>
     <li>The direction to move the head (left or right).</li>
     <li>The next state to transition to.</li>
 </ul>
 <p>The machine halts when it enters an accept or reject state, or if there is no valid transition.</p>

 <h2>Types of Turing Machines</h2>
 <ul>
     <li><strong>Deterministic Turing Machine (DTM)</strong>: For every state and symbol, there is exactly one defined action.</li>
     <li><strong>Non-Deterministic Turing Machine (NDTM)</strong>: Allows multiple possible actions for a given state and symbol.</li>
     <li><strong>Multi-Tape Turing Machine</strong>: Features multiple tapes and corresponding heads for more efficient computation.</li>
     <li><strong>Universal Turing Machine (UTM)</strong>: Can simulate any other Turing machine by encoding its description and input on the tape.</li>
 </ul>

 <div class="example">
     <h3>Example: Formal Definition</h3>
     <p>A Turing Machine is formally defined as:</p>
     <pre>
M = (Q, &Sigma;, &Gamma;, &delta;, q<sub>0</sub>, q<sub>accept</sub>, q<sub>reject</sub>)
Where:
- Q = {q<sub>0</sub>, q<sub>1</sub>, q<sub>accept</sub>, q<sub>reject</sub>} (states)
- &Sigma; = {0, 1} (input alphabet)
- &Gamma; = {0, 1, &square;} (tape alphabet)
- &delta; = Transition function (example depends on specific problem)
- q<sub>0</sub>, q<sub>accept</sub>, q<sub>reject</sub>: Start, accept, and reject states
     </pre>
 </div>


 <h3>Regular Expression to DFA</h3>

 <h2>Steps to Convert Regular Expression to DFA</h2>
 <p>The process of converting a regular expression to a Deterministic Finite Automaton (DFA) typically involves the following steps:</p>
 <ol>
     <li><strong>Convert Regular Expression to NFA</strong>: Use Thompson's construction to create a Non-Deterministic Finite Automaton (NFA).</li>
     <li><strong>Convert NFA to DFA</strong>: Apply the subset construction algorithm to transform the NFA into an equivalent DFA.</li>
     <li><strong>Minimize the DFA</strong> (optional): Simplify the DFA by merging equivalent states.</li>
 </ol>

 <h2>Key Concepts</h2>
 <ul>
     <li><strong>Regular Expression:</strong> A sequence of characters that define a search pattern, e.g., <code>a*b|c</code>.</li>
     <li><strong>NFA:</strong> A finite automaton where transitions can be non-deterministic (i.e., multiple transitions for the same input or &epsilon;-transitions).</li>
     <li><strong>DFA:</strong> A finite automaton where each state has exactly one transition per input symbol.</li>
 </ul>

 <h2>Example</h2>
 <div class="example">
     <h3>Convert Regular Expression <code>(a|b)*abb</code> to DFA</h3>
     <ol>
         <li><strong>Step 1:</strong> Construct an NFA for <code>(a|b)*abb</code> using Thompson's construction.
             <ul>
                 <li><code>(a|b)</code>: Create an NFA for alternation.</li>
                 <li><code>(a|b)*</code>: Add a loop for Kleene star.</li>
                 <li><code>abb</code>: Concatenate NFAs for each character.</li>
             </ul>
         </li>
         <li><strong>Step 2:</strong> Convert the NFA to a DFA using the subset construction algorithm:
             <ul>
                 <li>Identify all possible sets of NFA states (subsets).</li>
                 <li>Define transitions between subsets based on input symbols.</li>
             </ul>
         </li>
         <li><strong>Step 3:</strong> Minimize the DFA:
             <ul>
                 <li>Merge equivalent states to reduce the number of states.</li>
             </ul>
         </li>
     </ol>
 </div>
 <h2>Formal Definitions</h2>
 <ul>
     <li><strong>Regular Expression:</strong> A formal language over an alphabet <code>&Sigma;</code>.</li>
     <li><strong>NFA:</strong> Defined as a 5-tuple <code>(Q, &Sigma;, &delta;, q<sub>0</sub>, F)</code> where:
         <ul>
             <li><code>Q</code>: Finite set of states.</li>
             <li><code>&Sigma;</code>: Input alphabet.</li>
             <li><code>&delta;</code>: Transition function (<code>Q &times; (&Sigma; &cup; {&epsilon;}) &rarr; 2^Q</code>).</li>
             <li><code>q<sub>0</sub></code>: Start state.</li>
             <li><code>F</code>: Set of accept states.</li>
         </ul>
     </li>
     <li><strong>DFA:</strong> Defined as a 5-tuple <code>(Q, &Sigma;, &delta;, q<sub>0</sub>, F)</code> where:
         <ul>
             <li><code>Q</code>: Finite set of states.</li>
             <li><code>&Sigma;</code>: Input alphabet.</li>
             <li><code>&delta;</code>: Transition function (<code>Q &times; &Sigma; &rarr; Q</code>).</li>
             <li><code>q<sub>0</sub></code>: Start state.</li>
             <li><code>F</code>: Set of accept states.</li>
         </ul>
     </li>
 </ul>

 <h2>Turing Machine</h2>

 <h3>Definition</h3>
 <p>A Turing Machine (TM) is a mathematical model of computation that defines an abstract machine. It manipulates symbols on a strip of tape according to a set of rules and serves as a fundamental concept in theoretical computer science.</p>

 <h3>Representation of Turing Machines</h3>
 <ul>
     <li>A Turing Machine consists of:
         <ul>
             <li>A tape divided into cells, each capable of holding a symbol.</li>
             <li>A head that can read and write symbols on the tape and move left or right.</li>
             <li>A finite set of states, including a start state and one or more halt states.</li>
             <li>A transition function that defines the machine's behavior based on the current state and symbol.</li>
         </ul>
     </li>
 </ul>

 <h3>Variants of Turing Machines</h3>
 <ul>
     <li>Multi-tape Turing Machines</li>
     <li>Non-deterministic Turing Machines</li>
     <li>Universal Turing Machines</li>
     <li>Oracle Turing Machines</li>
 </ul>

 <h3>Design of Turing Machines</h3>
 <p>The process of designing a Turing Machine involves:</p>
 <ol>
     <li>Defining the input alphabet and tape alphabet.</li>
     <li>Specifying the states and transitions.</li>
     <li>Constructing the transition function to solve a specific problem.</li>
     <li>Testing the machine with sample inputs to verify its correctness.</li>
 </ol>

 <h3>Linear Bounded Automata</h3>
 <p>A Linear Bounded Automaton (LBA) is a restricted form of Turing Machine where the tape is limited to a finite segment proportional to the input size. LBAs are used to recognize context-sensitive languages.</p>

 <h3>Computational Complexity & Decidability</h3>
 <p>Computational complexity examines the resources required for a Turing Machine to solve a problem, including time and space. Decidability refers to whether a problem can be solved by a Turing Machine in finite time.</p>

 <h3>Recursively Enumerable Languages</h3>
 <p>A language is recursively enumerable (RE) if there exists a Turing Machine that can enumerate all strings in the language. RE languages may not be decidable but are semi-decidable.</p>

 <h3>Complexity</h3>
 <ul>
     <li>Time Complexity: Measures the number of steps a Turing Machine takes to solve a problem.</li>
     <li>Space Complexity: Measures the amount of tape used during computation.</li>
 </ul>

 <h3>Decidability</h3>
 <p>Decidability categorizes problems into:</p>
 <ul>
     <li><strong>Decidable Problems:</strong> Problems for which a Turing Machine halts with a yes/no answer for every input.</li>
     <li><strong>Undecidable Problems:</strong> Problems for which no Turing Machine can provide a solution for all inputs.</li>
 </ul>

 <h3>Halting Problem of Turing Machines</h3>
 <p>The Halting Problem is a classic example of an undecidable problem. It asks whether a Turing Machine will halt on a given input. Alan Turing proved that no general algorithm can solve this problem for all possible machine-input pairs.</p>


 <h2>Turing Machine Numericals</h2>

    <h3>Example 1: Design a Turing Machine to Recognize Strings with Equal Number of 0s and 1s</h3>
    <p><strong>Problem:</strong> Create a Turing Machine that accepts strings containing an equal number of 0s and 1s, such as "0011" or "1100".</p>
    <p><strong>Solution:</strong>
        <ul>
            <li>Mark the first unprocessed 0 and search for a corresponding 1 to mark.</li>
            <li>If a corresponding 1 is found, continue. If not, reject the string.</li>
            <li>Repeat until all 0s and 1s are processed.</li>
            <li>If all symbols are matched and no unprocessed symbols remain, accept the string.</li>
        </ul>
    </p>
    <br>
    <img src="../assets/images/formal/auto_tuni1.png" alt="" id="img1">
    <h3>Example 2: Turing Machine for Binary Addition</h3>
    <p><strong>Problem:</strong> Design a Turing Machine that adds two binary numbers represented on the tape, separated by a blank.</p>
    <p><strong>Solution:</strong>
        <ul>
            <li>Scan the tape to identify the two binary numbers.</li>
            <li>Perform bit-by-bit addition from right to left, carrying over as necessary.</li>
            <li>Write the result back to the tape, replacing the original numbers.</li>
        </ul>
    </p>

    <h3>Example 3: Turing Machine for Palindrome Detection</h3>
    <p><strong>Problem:</strong> Construct a Turing Machine to check if a string is a palindrome (e.g., "abba").</p>
    <p><strong>Solution:</strong>
        <ul>
            <li>Mark the first and last symbols and check if they are the same.</li>
            <li>Move inward and repeat for all pairs of symbols.</li>
            <li>If all pairs match, accept the string. Otherwise, reject it.</li>
        </ul>
    </p>

    <h3>Example 4: Turing Machine for Unary Multiplication</h3>
    <p><strong>Problem:</strong> Design a Turing Machine to compute the product of two unary numbers (e.g., "111*11" represents 3*2).</p>
    <p><strong>Solution:</strong>
        <ul>
            <li>Replicate the first number for each 1 in the second number.</li>
            <li>Separate the product with a designated delimiter.</li>
            <li>Ensure correctness by iteratively testing outputs with sample inputs.</li>
        </ul>
    </p>


 <hr>
 <center>Other important Questions</center>
 <hr>
 1) Convert the given NFA to DFA.
 <br><img src="../assets/images/formal/q1_more.png" alt="" id="img1">
 <br><br>
 2) Convert the given NFA to DFA.
 <br><img src="../assets/images/formal/q2_more.png" alt="" id="img1">
 <br><br>
 3) Design the NFA for the given transition table. 
 <img src="../assets/images/formal/q3_more.png" alt="" id="img1"><br><br>
   </section>


        </body>
</html>